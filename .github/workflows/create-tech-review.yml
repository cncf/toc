name: Create Tech Review Issue

on:
  issues:
    types: [labeled]

jobs:
  create-tech-review:
    if: github.event.label.name == 'review/tech'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Extract issue information and create tech review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // --- Constants ---
            const FIELD_LABELS = {
              name: [
                'Project name', 'Name', 'name', 'project name', 'project-name', 'subproject-name', 'Project Name', 'Subproject Name'
              ],
              projectLink: [
                'Project Repo(s)', 'Project Repo', 'Project link', 'project-link', 'project link', 'github-url', 'GitHub URL', 'Project link', 'Project Site'
              ],
              ddLink: [
                'Due diligence link', 'dd-link', 'due diligence link', 'Due diligence', 'Due diligence link'
              ],
              projectContact: [
                'Project points of contacts', 'Project points of contact', 'Project contact', 'project-contact', 'project contact', 'Project contact information', 'Project Security Contacts', 'Communication'
              ],
              additionalInfo: [
                'Additional information', 'additional-information', 'additional information', 'Additional Information', 'Additional information'
              ]
            };

            const LABELS_TECH_REVIEW = [
              'needs-triage', 'kind/initiative', 'review/tech', 'sub/project-review'
            ];

            const COMMENT_MARKERS = {
              techReviewCreated: 'Created tech review issue:',
              missingProjectName: 'Could not extract project name',
              missingProjectLink: 'Could not extract project link',
              createTechReviewFailed: 'Failed to create tech review issue'
            };

            // --- Helper Functions ---
            async function hasExistingComment(issueNumber, marker) {
              try {
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                });
                return comments.some(comment =>
                  comment.user.type === 'Bot' &&
                  comment.body.includes(marker)
                );
              } catch (error) {
                console.log('‚ö†Ô∏è  Error checking for existing comments:', error.message);
                return false;
              }
            }

            async function commentOnce(issueNumber, marker, body) {
              if (!(await hasExistingComment(issueNumber, marker))) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body
                });
              }
            }

            function extractFormField(body, fieldKey) {
              if (!body) return null;
              const labels = FIELD_LABELS[fieldKey] || [fieldKey];
              
              // First try GitHub template format: ### Field Label\n\nvalue
              for (const label of labels) {
                const escapedLabel = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const templatePattern = new RegExp(
                  `###\\s+${escapedLabel}[^\\n]*\\n\\n([\\s\\S]*?)(?=\\n###|$)`,
                  'i'
                );
                const templateMatch = body.match(templatePattern);
                if (templateMatch && templateMatch[1] && templateMatch[1].trim().length > 0) {
                  return templateMatch[1].trim();
                }
              }
              
              // Fallback: Try plain text format: Field Label: value
              for (const label of labels) {
                const escapedLabel = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Match "Field Label:" or "Field Label" followed by colon and value
                const plainPattern = new RegExp(
                  `^${escapedLabel}\\s*:?\\s+(.+)$`,
                  'im'
                );
                const plainMatch = body.match(plainPattern);
                if (plainMatch && plainMatch[1] && plainMatch[1].trim().length > 0) {
                  // Extract value, stopping at newline or end
                  const value = plainMatch[1].trim().split(/\n/)[0].trim();
                  if (value.length > 0) {
                    return value;
                  }
                }
              }
              
              return null;
            }

            function normalize(str) {
              return (str || '').trim().toLowerCase();
            }

            // --- Main Logic ---
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueTitle = issue.title || '';
            const issueBody = issue.body;
            const issueLabels = (issue.labels || [])
              .map(l => (typeof l === 'string' ? l : l?.name))
              .filter(Boolean);

            console.log(`üîç Processing issue #${issueNumber}`);
            console.log(`üìÑ Issue body length: ${issueBody ? issueBody.length : 0}`);
            console.log(`üè∑Ô∏è  Issue labels: ${issueLabels.join(', ')}`);

            // Guardrail: this workflow should run ONLY on "intake" issues that request a tech review.
            // It should NOT run on tech review issues themselves (including ones created by this workflow),
            // otherwise it can create duplicates.
            const AUTO_CREATED_MARKER = '_This issue was automatically created from [issue #';
            const isTechReviewTitle = /^\s*\[Tech Review\]\s*:/i.test(issueTitle);
            const isAutoCreatedTechReview = typeof issueBody === 'string' && issueBody.includes(AUTO_CREATED_MARKER);
            if (isTechReviewTitle || isAutoCreatedTechReview) {
              console.log(
                `‚ÑπÔ∏è  Skipping: issue appears to already be a Tech Review issue (title=${isTechReviewTitle}, autoCreated=${isAutoCreatedTechReview}).`
              );
              return;
            }

            // Extract fields
            const projectName = extractFormField(issueBody, 'name');
            const projectLink = extractFormField(issueBody, 'projectLink');
            const ddLink = extractFormField(issueBody, 'ddLink');
            const projectContact = extractFormField(issueBody, 'projectContact');
            const additionalInfo = extractFormField(issueBody, 'additionalInfo');

            console.log(`üìã Extracted fields:
              projectName: ${projectName || 'NOT FOUND'}
              projectLink: ${projectLink || 'NOT FOUND'}
              ddLink: ${ddLink || 'NOT FOUND'}
              projectContact: ${projectContact || 'NOT FOUND'}
              additionalInfo: ${additionalInfo ? 'FOUND' : 'NOT FOUND'}
            `);

            // Validate required fields
            if (!projectName) {
              console.log('‚ùå Missing project name - commenting and exiting');
              await commentOnce(issueNumber, COMMENT_MARKERS.missingProjectName,
                `‚ùå Could not extract project name from issue body. Please ensure the issue was created from a template with a "Project name" field.`);
              return;
            }
            if (!projectLink) {
              console.log('‚ùå Missing project link - commenting and exiting');
              await commentOnce(issueNumber, COMMENT_MARKERS.missingProjectLink,
                `‚ùå Could not extract project link from issue body. Please ensure the issue contains a "Project link" or "GitHub URL" field.`);
              return;
            }

            const normalizedProjectName = projectName.trim();
            const projectNameLower = normalize(projectName);

            // Check if tech review already created for this issue
            const hasExistingCommentCheck = await hasExistingComment(issueNumber, COMMENT_MARKERS.techReviewCreated);
            console.log(`üîç Checked for existing comment: ${hasExistingCommentCheck}`);
            if (hasExistingCommentCheck) {
              console.log('‚ÑπÔ∏è  Tech review issue already created for this issue - exiting');
              return;
            }

            // Check for existing tech review issues for this project
            let existingIssue = null;
            try {
              // GitHub label/issue listing can be eventually consistent right after issue creation/labeling.
              // Retry a few times with backoff to reduce accidental duplicates.
              const backoffMs = [0, 3000, 7000, 15000];
              for (let attempt = 0; attempt < backoffMs.length; attempt++) {
                const waitMs = backoffMs[attempt];
                if (waitMs > 0) {
                  console.log(`‚è≥ Retry ${attempt + 1}/${backoffMs.length}: waiting ${waitMs}ms before checking for existing tech review issues...`);
                  await new Promise(resolve => setTimeout(resolve, waitMs));
                } else {
                  console.log(`üîé Checking for existing tech review issues (attempt ${attempt + 1}/${backoffMs.length})...`);
                }

                const allIssues = await github.paginate(github.rest.issues.listForRepo, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  labels: 'review/tech',
                  per_page: 100
                });

                existingIssue = allIssues.find(item => {
                  if (item.number === issueNumber) return false;
                  // Only consider issues that look like tech review issues.
                  if (!/^\s*\[Tech Review\]\s*:/i.test(item.title || '')) return false;
                  const existingProjectName = extractFormField(item.body, 'name');
                  if (normalize(existingProjectName) === projectNameLower) return true;
                  // Fallback: check title for exact word match
                  const titleLower = (item.title || '').toLowerCase();
                  const projectNameRegex = new RegExp(`\\b${projectNameLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                  return projectNameRegex.test(titleLower);
                });

                if (existingIssue) break;
              }

              if (existingIssue) {
                console.log(`‚ÑπÔ∏è  Found existing tech review issue #${existingIssue.number} - exiting without commenting to avoid end-user noise`);
                return;
              } else {
                console.log('‚úÖ No existing tech review issue found - proceeding to create');
              }
            } catch (error) {
              console.log('‚ö†Ô∏è  Error checking for existing issues:', error.message);
            }

            // Build tech review issue body
            let issueBodyContent = `### Project name\n\n${normalizedProjectName}\n\n`;
            issueBodyContent += `### Project link\n\n${projectLink}\n\n`;
            issueBodyContent += `### Due diligence link\n\n${ddLink || ''}\n\n`;
            issueBodyContent += `### Project contact information\n\n${projectContact || 'To be provided'}\n\n`;
            issueBodyContent += `### Additional information\n\n${additionalInfo || ''}\n\n`;
            const originalIssueUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issueNumber}`;
            issueBodyContent += `---\n\n_This issue was automatically created from [issue #${issueNumber}](${originalIssueUrl})_`;

            // Create tech review issue
            console.log(`üöÄ Attempting to create tech review issue for: ${normalizedProjectName}`);
            try {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[Tech Review]: ${normalizedProjectName}`,
                body: issueBodyContent,
                labels: LABELS_TECH_REVIEW
              });

              console.log(`‚úÖ Successfully created issue #${newIssue.data.number}`);
              await commentOnce(issueNumber, COMMENT_MARKERS.techReviewCreated,
                `‚úÖ Created tech review issue: [#${newIssue.data.number} - ${newIssue.data.title}](${newIssue.data.html_url})`);
            } catch (error) {
              console.error(`‚ùå Error creating issue: ${error.message}`);
              console.error(`‚ùå Error stack: ${error.stack}`);
              await commentOnce(issueNumber, COMMENT_MARKERS.createTechReviewFailed,
                `‚ùå Failed to create tech review issue: ${error.message}`);
              throw error;
            }